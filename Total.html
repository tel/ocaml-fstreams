<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Partial.html">
<link rel="next" href="Void.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Partial" rel="Chapter" href="Partial.html">
<link title="Total" rel="Chapter" href="Total.html">
<link title="Void" rel="Chapter" href="Void.html"><link title="Value introduction " rel="Section" href="#introduction">
<link title="Value elimination " rel="Section" href="#elimination">
<link title="Streams are covariant functors" rel="Section" href="#functor">
<link title="Streams are applicative functors" rel="Section" href="#applicative">
<link title="Streams are comonads" rel="Section" href="#applicative">
<link title="Other operations " rel="Section" href="#extras">
<link title="Implementation" rel="Section" href="#impl">
<title>Total</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Partial.html" title="Partial">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Void.html" title="Void">Next</a>
</div>
<h1>Module <a href="type_Total.html">Total</a></h1>

<pre><span class="keyword">module</span> Total: <code class="code"><span class="keyword">sig</span></code> <a href="Total.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
Total, lazy, functional streams; guaranteed to be unending.
<p>

    Streams are lazy data structures which contain values in
    sequence. Due to laziness, streams may be infinite (e.g. <a href="Total.html#VALints"><code class="code"><span class="constructor">Total</span>.ints</code></a>
    below). The streams in this module are "total" referring to the
    fact that <a href="Total.html#elimination"><code class="code">eliminators</code></a> like <a href="Total.html#VALhead"><code class="code"><span class="constructor">Total</span>.head</code></a>, <a href="Total.html#VALtail"><code class="code"><span class="constructor">Total</span>.tail</code></a>, and
    <a href="Total.html#VALuncons"><code class="code"><span class="constructor">Total</span>.uncons</code></a> return pure values implying that there is never an end
    to the sequence of contained values.
<p>

    The streams in <a href="Partial.html"><code class="code"><span class="constructor">Partial</span></code></a> are a sister datatype to these streams
    which is "partial", e.g. <a href="Partial.html#VALuncons"><code class="code"><span class="constructor">Partial</span>.uncons</code></a> returns values wrapped
    in <code class="code">option</code>.
<p>

    Mathematically, total streams are the greatest fixed point of the
    functor <code class="code"><span class="constructor">F</span> <span class="constructor">X</span> = <span class="constructor">A</span> * <span class="constructor">X</span></code>.<br>
</div>
<hr width="100%">

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type">+'a</code> t</span> </pre>
<div class="info ">
A total lazy stream; a necessarily unbounded sequence of values of
    type <code class="code"><span class="keywordsign">'</span>a</code>.<br>
</div>

<br>
<h1 id="introduction">Value introduction </h1><br>

<pre><span id="VALcons"><span class="keyword">val</span> cons</span> : <code class="type">'a -> 'a <a href="Total.html#TYPEt">t</a> -> 'a <a href="Total.html#TYPEt">t</a></code></pre><div class="info ">
Extend a stream by prepending a value.<br>
</div>

<pre><span id="VALunfold"><span class="keyword">val</span> unfold</span> : <code class="type">('s -> 'a * 's) -> 's -> 'a <a href="Total.html#TYPEt">t</a></code></pre><div class="info ">
Lazily unfolds a total stream. In each step of <code class="code">unfold build s</code>,
    the current seed is passed to <code class="code">build</code> the next value of the stream
    and the new seed value, e.g.
<p>

    <pre class="codepre"><code class="code">&nbsp;<span class="keyword">let</span>&nbsp;ints&nbsp;:&nbsp;int&nbsp;t&nbsp;=&nbsp;unfold&nbsp;(<span class="keyword">fun</span>&nbsp;n&nbsp;<span class="keywordsign">-&gt;</span>&nbsp;(n,&nbsp;n+1))&nbsp;0&nbsp;</code></pre><br>
</div>

<pre><span id="VALtrajectory"><span class="keyword">val</span> trajectory</span> : <code class="type">('a -> 'a) -> 'a -> 'a <a href="Total.html#TYPEt">t</a></code></pre><div class="info ">
Generate an infinite stream from the trajectory of a
    endomorphism. In other words, <code class="code">head (trajectory f a) = a</code> and
    <code class="code">tail (trajectory f a) = trajectory f (f a)</code><br>
</div>

<pre><span id="VALimpure"><span class="keyword">val</span> impure</span> : <code class="type">(unit -> 'a) -> 'a <a href="Total.html#TYPEt">t</a></code></pre><div class="info ">
Generates a list impurely. Each new value of the stream <code class="code">impure f</code>
    is produced by calling <code class="code">f ()</code>. See also <a href="Total.html#VALtabulate"><code class="code"><span class="constructor">Total</span>.tabulate</code></a>.<br>
</div>

<pre><span id="VALtabulate"><span class="keyword">val</span> tabulate</span> : <code class="type">(int -> 'a) -> 'a <a href="Total.html#TYPEt">t</a></code></pre><div class="info ">
Generates a stream by tabulation of values.
<p>

    Total streams can be seen as memoizations of functions of type
    <code class="code">int <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a</code>, so <a href="Total.html#VALtabulate"><code class="code"><span class="constructor">Total</span>.tabulate</code></a> witnesses part of this isomorphism.
<p>

    See <a href="Total.html#VALnth"><code class="code"><span class="constructor">Total</span>.nth</code></a>.<br>
</div>

<pre><span id="VALints"><span class="keyword">val</span> ints</span> : <code class="type">int <a href="Total.html#TYPEt">t</a></code></pre><div class="info ">
An infinite stream of all integers.<br>
</div>
<br>
<i>See also</i>: <a href="Total.html#VALpure"><code class="code"><span class="constructor">Total</span>.pure</code></a><br>
<br>
<h1 id="elimination">Value elimination </h1><br>

<pre><span id="VALhead"><span class="keyword">val</span> head</span> : <code class="type">'a <a href="Total.html#TYPEt">t</a> -> 'a</code></pre>
<pre><span id="VALtail"><span class="keyword">val</span> tail</span> : <code class="type">'a <a href="Total.html#TYPEt">t</a> -> 'a <a href="Total.html#TYPEt">t</a></code></pre>
<pre><span id="VALuncons"><span class="keyword">val</span> uncons</span> : <code class="type">'a <a href="Total.html#TYPEt">t</a> -> 'a * 'a <a href="Total.html#TYPEt">t</a></code></pre><div class="info ">
The "principle eliminator" for a stream. Can be used along with
    recursion to derive all of the others.<br>
</div>

<pre><span id="VALfold"><span class="keyword">val</span> fold</span> : <code class="type">('a -> 'r Lazy.t -> 'r) -> 'a <a href="Total.html#TYPEt">t</a> -> 'r</code></pre><div class="info ">
Non-strict right fold. One must be careful in <code class="code">f</code> about forcing
    the second argument only as needed; <code class="code">fold f z s</code> <i>can</i> return in
    finite time, but won't if it is too strict.
<p>

    This is the principle recursor of a total stream. Essentially any
    function eliminating streams can be derived from <a href="Total.html#VALfold"><code class="code"><span class="constructor">Total</span>.fold</code></a>.<br>
</div>

<pre><span id="VALiter"><span class="keyword">val</span> iter</span> : <code class="type">('a -> unit) -> 'a <a href="Total.html#TYPEt">t</a> -> <a href="Void.html#TYPEt">Void.t</a></code></pre><div class="info ">
Impure consumption of a stream. <i>Note</i> that this function will
    never return.<br>
</div>

<pre><span id="VALnth"><span class="keyword">val</span> nth</span> : <code class="type">int -> 'a <a href="Total.html#TYPEt">t</a> -> 'a</code></pre><div class="info ">
Convert a stream into an accessor function on index. See
    <a href="Total.html#VALtabulate"><code class="code"><span class="constructor">Total</span>.tabulate</code></a>.<br>
</div>
<br>
<h1 id="functor">Streams are <i>covariant functors</i></h1><br>

<pre><span id="VALmap"><span class="keyword">val</span> map</span> : <code class="type">('a -> 'b) -> 'a <a href="Total.html#TYPEt">t</a> -> 'b <a href="Total.html#TYPEt">t</a></code></pre><div class="info ">
Applies a function valuewise to a stream.<br>
</div>
<br>
<h1 id="applicative">Streams are <i>applicative</i> functors</h1><br>
<br>
Streams are "zippy" applicative functors.<br>

<pre><span id="VALpure"><span class="keyword">val</span> pure</span> : <code class="type">'a -> 'a <a href="Total.html#TYPEt">t</a></code></pre><div class="info ">
Produces the infinite, constant stream of some value.<br>
</div>

<pre><span id="VALap"><span class="keyword">val</span> ap</span> : <code class="type">('a -> 'b) <a href="Total.html#TYPEt">t</a> -> 'a <a href="Total.html#TYPEt">t</a> -> 'b <a href="Total.html#TYPEt">t</a></code></pre><div class="info ">
"Zips" a stream of functions with a stream of their arguments
    returning the resulting list.<br>
</div>

<pre><span id="VALmap2"><span class="keyword">val</span> map2</span> : <code class="type">('a -> 'b -> 'c) -> 'a <a href="Total.html#TYPEt">t</a> -> 'b <a href="Total.html#TYPEt">t</a> -> 'c <a href="Total.html#TYPEt">t</a></code></pre><div class="info ">
A generalization of <a href="Total.html#VALmap"><code class="code"><span class="constructor">Total</span>.map</code></a> afforded by <a href="Total.html#VALpure"><code class="code"><span class="constructor">Total</span>.pure</code></a> and <a href="Total.html#VALap"><code class="code"><span class="constructor">Total</span>.ap</code></a>. This
    version may be more efficient than the equivalent version produced
    using <a href="Total.html#VALpure"><code class="code"><span class="constructor">Total</span>.pure</code></a> and <a href="Total.html#VALap"><code class="code"><span class="constructor">Total</span>.ap</code></a>.
    <pre class="codepre"><code class="code">&nbsp;map2&nbsp;f&nbsp;a&nbsp;b&nbsp;=&nbsp;ap&nbsp;(ap&nbsp;(pure&nbsp;f)&nbsp;a)&nbsp;b&nbsp;</code></pre><br>
</div>

<pre><span id="VALmap3"><span class="keyword">val</span> map3</span> : <code class="type">('a -> 'b -> 'c -> 'd) -><br>       'a <a href="Total.html#TYPEt">t</a> -> 'b <a href="Total.html#TYPEt">t</a> -> 'c <a href="Total.html#TYPEt">t</a> -> 'd <a href="Total.html#TYPEt">t</a></code></pre><div class="info ">
A generalization of <a href="Total.html#VALmap"><code class="code"><span class="constructor">Total</span>.map</code></a> afforded by <a href="Total.html#VALpure"><code class="code"><span class="constructor">Total</span>.pure</code></a> and <a href="Total.html#VALap"><code class="code"><span class="constructor">Total</span>.ap</code></a>. This
    version may be more efficient than the equivalent version produced
    using <a href="Total.html#VALpure"><code class="code"><span class="constructor">Total</span>.pure</code></a> and <a href="Total.html#VALap"><code class="code"><span class="constructor">Total</span>.ap</code></a>.
    <pre class="codepre"><code class="code">&nbsp;map3&nbsp;f&nbsp;a&nbsp;b&nbsp;c&nbsp;=&nbsp;ap&nbsp;(ap&nbsp;(ap&nbsp;(pure&nbsp;f)&nbsp;a)&nbsp;b)&nbsp;c&nbsp;</code></pre><br>
</div>
<br>
<h1 id="applicative">Streams are <i>comonads</i></h1><br>
<br>
Streams are comonads focused on their "zero" element.<br>

<pre><span id="VALextract"><span class="keyword">val</span> extract</span> : <code class="type">'a <a href="Total.html#TYPEt">t</a> -> 'a</code></pre><div class="info ">
Extract the focused element, e.g. <code class="code">extract s = nth s 0</code>.<br>
</div>

<pre><span id="VALextend"><span class="keyword">val</span> extend</span> : <code class="type">('a <a href="Total.html#TYPEt">t</a> -> 'b) -> 'a <a href="Total.html#TYPEt">t</a> -> 'b <a href="Total.html#TYPEt">t</a></code></pre><div class="info ">
Apply a function from streams to summary values at all points in
    time. In other words <code class="code">head (extend f s) = f s</code> and <code class="code">tail (extend f
    s) = extend f (push s)</code>.<br>
</div>
<br>
<h1 id="extras">Other operations </h1><br>

<pre><span id="VALinterleave"><span class="keyword">val</span> interleave</span> : <code class="type">'a <a href="Total.html#TYPEt">t</a> -> 'a <a href="Total.html#TYPEt">t</a> -> 'a <a href="Total.html#TYPEt">t</a></code></pre><div class="info ">
Interleaves two streams
<p>
Interleaves two streams, non-associative. For instance, the
    streams <code class="code"><span class="keyword">let</span> x = [1;2;3;...]</code> and <code class="code"><span class="keyword">let</span> y = [a;b;c;...]</code> are
    interwoven to form <code class="code">interleave x y = [1;a;2;b;3;c;...]</code>.<br>
</div>

<pre><span id="VALpush"><span class="keyword">val</span> push</span> : <code class="type">'a <a href="Total.html#TYPEt">t</a> -> 'a <a href="Total.html#TYPEt">t</a></code></pre><div class="info ">
If a stream <code class="code">s</code> is interpreted as a process through time then
    <code class="code">delay s</code> is the same process beginning at <pre class="verbatim">t=-1</pre> instead of
    <pre class="verbatim">t=0</pre>.
<p>

    For total streams, <code class="code">delay</code> is identical to <a href="Total.html#VALtail"><code class="code"><span class="constructor">Total</span>.tail</code></a>.<br>
</div>

<pre><span id="VALtake"><span class="keyword">val</span> take</span> : <code class="type">int -> 'a <a href="Total.html#TYPEt">t</a> -> 'a list</code></pre><div class="info ">
Convert a prefix of a stream into a <code class="code">list</code>. Note that the list
    <code class="code">take n s</code> is not necessarily as long as <code class="code">n</code>.<br>
</div>

<pre><span id="VALdrop"><span class="keyword">val</span> drop</span> : <code class="type">int -> 'a <a href="Total.html#TYPEt">t</a> -> 'a <a href="Total.html#TYPEt">t</a></code></pre><div class="info ">
Trim off a prefix of a stream.<br>
</div>

<pre><span id="VALinits"><span class="keyword">val</span> inits</span> : <code class="type">'a <a href="Total.html#TYPEt">t</a> -> 'a list <a href="Total.html#TYPEt">t</a></code></pre><div class="info ">
Stream all prefixes of a stream.<br>
</div>

<pre><span id="VALtails"><span class="keyword">val</span> tails</span> : <code class="type">'a <a href="Total.html#TYPEt">t</a> -> 'a <a href="Total.html#TYPEt">t</a> <a href="Total.html#TYPEt">t</a></code></pre><div class="info ">
Stream all suffixes of a stream.<br>
</div>

<pre><span id="VALkeep"><span class="keyword">val</span> keep</span> : <code class="type">('a -> 'b option) -> 'a <a href="Total.html#TYPEt">t</a> -> 'b <a href="Total.html#TYPEt">t</a></code></pre><div class="info ">
Transform a stream dropping some elements. See <a href="Total.html#VALmap"><code class="code"><span class="constructor">Total</span>.map</code></a>.<br>
</div>

<pre><span id="VALfilter"><span class="keyword">val</span> filter</span> : <code class="type">('a -> bool) -> 'a <a href="Total.html#TYPEt">t</a> -> 'a <a href="Total.html#TYPEt">t</a></code></pre><div class="info ">
Dropping some elements of a stream. See <a href="Total.html#VALkeep"><code class="code"><span class="constructor">Total</span>.keep</code></a>.<br>
</div>
<br>
<h1 id="impl">Implementation</h1><br>
<br>
The stream implementation is exposed to allow certain tricky
    definitions. <i>This will hopefully be removed in later
    versions, try not to depend upon it!</i><br>

<pre><span class="keyword">module</span> <a href="Total.Impl.html">Impl</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Total.Impl.html">..</a> <code class="code"><span class="keyword">end</span></code></pre></body></html>